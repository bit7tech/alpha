//----------------------------------------------------------------------------------------------------------------------
// Rendering routines
// This should only be included once.
//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------
// Font

extern const u8 gFont[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00,
    0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x24, 0x7e, 0x24, 0x24, 0x7e, 0x24, 0x00,
    0x00, 0x08, 0x3e, 0x28, 0x3e, 0x0a, 0x3e, 0x08,
    0x00, 0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00,
    0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
    0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
    0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
    0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
    0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00,
    0x00, 0x3c, 0x46, 0x4a, 0x52, 0x62, 0x3c, 0x00,
    0x00, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3e, 0x00,
    0x00, 0x3c, 0x42, 0x02, 0x3c, 0x40, 0x7e, 0x00,
    0x00, 0x3c, 0x42, 0x0c, 0x02, 0x42, 0x3c, 0x00,
    0x00, 0x08, 0x18, 0x28, 0x48, 0x7e, 0x08, 0x00,
    0x00, 0x7e, 0x40, 0x7c, 0x02, 0x42, 0x3c, 0x00,
    0x00, 0x3c, 0x40, 0x7c, 0x42, 0x42, 0x3c, 0x00,
    0x00, 0x7e, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00,
    0x00, 0x3c, 0x42, 0x3c, 0x42, 0x42, 0x3c, 0x00,
    0x00, 0x3c, 0x42, 0x42, 0x3e, 0x02, 0x3c, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x10, 0x20,
    0x00, 0x00, 0x04, 0x08, 0x10, 0x08, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x08, 0x04, 0x08, 0x10, 0x00,
    0x00, 0x3c, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
    0x00, 0x3c, 0x4a, 0x56, 0x5e, 0x40, 0x3c, 0x00,
    0x00, 0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00,
    0x00, 0x7c, 0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00,
    0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x00,
    0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00,
    0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00,
    0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00,
    0x00, 0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c, 0x00,
    0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00,
    0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00,
    0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3c, 0x00,
    0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,
    0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00,
    0x00, 0x42, 0x66, 0x5a, 0x42, 0x42, 0x42, 0x00,
    0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00,
    0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,
    0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x00,
    0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x3c, 0x00,
    0x00, 0x7c, 0x42, 0x42, 0x7c, 0x44, 0x42, 0x00,
    0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00,
    0x00, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,
    0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00,
    0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00,
    0x00, 0x42, 0x42, 0x42, 0x42, 0x5a, 0x24, 0x00,
    0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00,
    0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x00,
    0x00, 0x7e, 0x04, 0x08, 0x10, 0x20, 0x7e, 0x00,
    0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
    0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
    0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
    0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    0x00, 0x1c, 0x22, 0x78, 0x20, 0x20, 0x7e, 0x00,
    0x00, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3c, 0x00,
    0x00, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x3c, 0x00,
    0x00, 0x00, 0x1c, 0x20, 0x20, 0x20, 0x1c, 0x00,
    0x00, 0x04, 0x04, 0x3c, 0x44, 0x44, 0x3c, 0x00,
    0x00, 0x00, 0x38, 0x44, 0x78, 0x40, 0x3c, 0x00,
    0x00, 0x0c, 0x10, 0x18, 0x10, 0x10, 0x10, 0x00,
    0x00, 0x00, 0x3c, 0x44, 0x44, 0x3c, 0x04, 0x38,
    0x00, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x00,
    0x00, 0x10, 0x00, 0x30, 0x10, 0x10, 0x38, 0x00,
    0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 0x24, 0x18,
    0x00, 0x20, 0x28, 0x30, 0x30, 0x28, 0x24, 0x00,
    0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0c, 0x00,
    0x00, 0x00, 0x68, 0x54, 0x54, 0x54, 0x54, 0x00,
    0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00,
    0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40,
    0x00, 0x00, 0x3c, 0x44, 0x44, 0x3c, 0x04, 0x06,
    0x00, 0x00, 0x1c, 0x20, 0x20, 0x20, 0x20, 0x00,
    0x00, 0x00, 0x38, 0x40, 0x38, 0x04, 0x78, 0x00,
    0x00, 0x10, 0x38, 0x10, 0x10, 0x10, 0x0c, 0x00,
    0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x00, 0x00, 0x44, 0x44, 0x28, 0x28, 0x10, 0x00,
    0x00, 0x00, 0x44, 0x54, 0x54, 0x54, 0x28, 0x00,
    0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x00, 0x44, 0x44, 0x44, 0x3c, 0x04, 0x38,
    0x00, 0x00, 0x7c, 0x08, 0x10, 0x20, 0x7c, 0x00,
    0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
    0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
    0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
    0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3c, 0x42, 0x99, 0xa1, 0xa1, 0x99, 0x42, 0x3c,
};

//----------------------------------------------------------------------------------------------------------------------

void plot(GameOffScreenBuffer& buffer, int x, int y, u32 colour)
{
    assert(x < buffer.width);
    assert(y < buffer.height);
    assert(x >= 0 && y >= 0);

    buffer.memory[y*buffer.width + x] = colour;
}

//----------------------------------------------------------------------------------------------------------------------
// Draw text

void charInfo(const u8* font, char c, u8& outMask, int& outLShift, int& outWidth)
{
    const u8* pixels = &font[(c - ' ') * 8];
    outLShift = 0;
    outMask = 0;

    // Prepare the mask by ORing all the bytes.
    // If the mask is blank (i.e. a space), create one of width 6.
    for (int i = 0; i < 8; ++i) outMask |= pixels[i];
    if (0 == outMask) outMask = 0xfc;

    // Make sure there is only 1 pixel at most to the left of the mask
    for (u8 b = 0xc0; ((outMask << outLShift) & b) == 0; ) ++outLShift;

    outWidth = 8 - outLShift;
    u8 mask = outMask;
    while ((mask & 1) == 0)
    {
        --outWidth;
        mask >>= 1;
    }
}

int drawChar(GameOffScreenBuffer& buffer, int x, int y, char c, u32 ink, u32 paper, const u8* font = gFont)
{
    // #todo: Put the mask/lshift calculations in a table
    // #todo: Do fast and/or pixel writes by moving bounds check outside calls.

    if (c < 32 || c > 127) c = '.';

    // Calculate the character information (mask, left adjust and width)
    u8 mask = 0;
    int lShift = 0;
    int width = 0;
    charInfo(font, c, mask, lShift, width);

    u32* p = buffer.memory + (y * buffer.width) + x;

    const u8* pixels = &font[(c - ' ') * 8];

    for (int r = 0; r < 8; ++r)
    {
        u8 row = (*pixels & mask) << lShift;
        for (int c = 0; c < width; ++c)
        {
            *p++ = (row & 0x80) ? ink : paper;
            row <<= 1;
        }
        p += (buffer.width - width);
        ++pixels;
    }

    return x + width;
}

void drawString(GameOffScreenBuffer& buffer, int x, int y, const char* str, u32 ink, u32 paper, const u8* font = gFont)
{
    for (; *str; ++str)
    {
        x = drawChar(buffer, x, y, *str, ink, paper, font);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Draw a rectangle

void drawRect(GameOffScreenBuffer& buffer, int x, int y, int width, int height, u32 colour)
{
    u32* p = buffer.memory + (y * buffer.width) + x;
    for (int r = 0; r < height; ++r)
    {
        for (int c = 0; c < width; ++c, ++p)
        {
            *p = colour;
        }
        p += (buffer.width - width);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Draw open rectangle

void drawOpenRect(GameOffScreenBuffer& buffer, int x, int y, int width, int height, u32 outlineColour, u32 insideColour)
{
    u32* p = buffer.memory + (y * buffer.width) + x;
    for (int r = 0; r < height; ++r)
    {
        for (int c = 0; c < width; ++c, ++p)
        {
            u32 colour = (r == 0 || c == 0 || r == width - 1 || c == height - 1) ? outlineColour : insideColour;
            *p = colour;
        }
        p += (buffer.width - width);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Draw a line from x1,y1 to x2,y2 including both endpoints.

void drawLine(GameOffScreenBuffer& buffer, int x1, int y1, int x2, int y2, u32 colour)
{
    assert(x1 >= 0 && x1 < buffer.width);
    assert(x2 >= 0 && x2 < buffer.width);
    assert(y1 >= 0 && y1 < buffer.height);
    assert(y2 >= 0 && y2 < buffer.height);

    const bool steep = (fabs(y2 - y1) > fabs(x2 - x1));
    if (steep)
    {
        std::swap(x1, y1);
        std::swap(x2, y2);
    }

    if (x1 > x2)
    {
        std::swap(x1, x2);
        std::swap(y1, y2);
    }

    const int dx = x2 - x1;
    const int dy = abs(y2 - y1);

    int error = dx / 2;
    const int ystep = (y1 < y2) ? 1 : -1;
    int y = (int)y1;

    for (int x = (int)x1; x <= x2; x++)
    {
        if (steep)
        {
            plot(buffer, y, x, colour);
        }
        else
        {
            plot(buffer, x, y, colour);
        }

        error -= dy;
        if (error < 0)
        {
            y += ystep;
            error += dx;
        }
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Graphic

struct Graphic
{
    Graphic(const u8* binary, u64 size)
    {
        int n;
        image = (u32 *)stbi_load_from_memory(binary, (int)size, &width, &height, &n, 0);
    }

    ~Graphic()
    {
        stbi_image_free(image);
    }

    u32* image;
    int width, height;
};

//----------------------------------------------------------------------------------------------------------------------

void drawGraphic(GameOffScreenBuffer& buffer, const Graphic& gfx, int x, int y,
    int sx, int sy, int srcWidth, int srcHeight)
{
    const u32* src = gfx.image;
    int dstStride = buffer.width - srcWidth;
    int srcStride = gfx.width - srcWidth;
    if (y + srcHeight >= buffer.height)
    {
        srcHeight = buffer.height - y;
    }

    u32* dst = buffer.memory + (y * buffer.width) + x;
    for (int r = 0; r < srcHeight; ++r)
    {
        for (int c = 0; c < srcWidth; ++c)
        {
            u8* s = (u8*)src;
            u8* d = (u8*)dst;
            f32 r1 = (f32)s[2] / 255.0f;
            f32 g1 = (f32)s[1] / 255.0f;
            f32 b1 = (f32)s[0] / 255.0f;
            f32 a = (f32)s[3] / 255.0f;
            f32 r2 = (f32)d[0] / 255.0f;
            f32 g2 = (f32)d[1] / 255.0f;
            f32 b2 = (f32)d[2] / 255.0f;

            assert(r1 >= 0.0f && r1 <= 1.0f);
            assert(g1 >= 0.0f && g1 <= 1.0f);
            assert(b1 >= 0.0f && b1 <= 1.0f);
            assert(r2 >= 0.0f && r2 <= 1.0f);
            assert(g2 >= 0.0f && g2 <= 1.0f);
            assert(b2 >= 0.0f && b2 <= 1.0f);

            f32 r = (r1 * a) + (r2 * (1.0f - a));
            f32 g = (g1 * a) + (g2 * (1.0f - a));
            f32 b = (b1 * a) + (b2 * (1.0f - a));

            assert(r >= 0 && r <= 1.0f);
            assert(g >= 0 && g <= 1.0f);
            assert(b >= 0 && b <= 1.0f);

            d[0] = (u8)(r * 255.0f);
            d[1] = (u8)(g * 255.0f);
            d[2] = (u8)(b * 255.0f);
            d[3] = 0xff;

            ++src;
            ++dst;
        }
        dst += dstStride;
        src += srcStride;
    }
}

//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
